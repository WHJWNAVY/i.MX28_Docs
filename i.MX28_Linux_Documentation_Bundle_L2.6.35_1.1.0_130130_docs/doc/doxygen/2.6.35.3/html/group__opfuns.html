<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MXC Linux BSP: Operational Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>Operational Functions</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#gbf1cb1bd38cbed4ef6f028dd11f2a821">fsl_shw_symmetric_encrypt</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *key_info, <a class="el" href="structfsl__shw__scco__t.html">fsl_shw_scco_t</a> *sym_ctx, uint32_t length, const uint8_t *pt, uint8_t *ct)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#gb4e80317d10ebeef1ffeef80668c9ccd">fsl_shw_symmetric_decrypt</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *key_info, <a class="el" href="structfsl__shw__scco__t.html">fsl_shw_scco_t</a> *sym_ctx, uint32_t length, const uint8_t *ct, uint8_t *pt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#ga9092309757f63584e6d05b133c5ef6c">fsl_shw_hash</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="structfsl__shw__hco__t.html">fsl_shw_hco_t</a> *hash_ctx, const uint8_t *msg, uint32_t length, uint8_t *result, uint32_t result_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#g68cfe8ee1d53a1759e961416ea74656d">fsl_shw_hmac_precompute</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *key_info, <a class="el" href="structfsl__shw__hmco__t.html">fsl_shw_hmco_t</a> *hmac_ctx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#gac83e16693bcfba44b4f7669c17c8e5a">fsl_shw_hmac</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *key_info, <a class="el" href="structfsl__shw__hmco__t.html">fsl_shw_hmco_t</a> *hmac_ctx, const uint8_t *msg, uint32_t length, uint8_t *result, uint32_t result_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#g2aba93b3238c1ead9a1e3fc5f4f2d619">fsl_shw_get_random</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, uint32_t length, uint8_t *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#g80cd0b9ba062845ef4eeac5413a0d579">fsl_shw_add_entropy</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, uint32_t length, uint8_t *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#g7e450fe979f833b3cc4da2c85c24b26e">fsl_shw_gen_encrypt</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="structfsl__shw__acco__t.html">fsl_shw_acco_t</a> *auth_ctx, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *cipher_key_info, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *auth_key_info, uint32_t auth_data_length, const uint8_t *auth_data, uint32_t payload_length, const uint8_t *payload, uint8_t *ct, uint8_t *auth_value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#g8d0b815bbd579551a2f9be604474e474">fsl_shw_auth_decrypt</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="structfsl__shw__acco__t.html">fsl_shw_acco_t</a> *auth_ctx, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *cipher_key_info, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *auth_key_info, uint32_t auth_data_length, const uint8_t *auth_data, uint32_t payload_length, const uint8_t *ct, const uint8_t *auth_value, uint8_t *payload)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#gd6f5a7a2e28817cf9e7d85d032826ef6">fsl_shw_establish_key</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *key_info, <a class="el" href="shw__driver_8h.html#2252cb841bd6ad23317850ff3f21575c">fsl_shw_key_wrap_t</a> establish_type, const uint8_t *key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#g3dab929899d17019f25fe84411fa17d4">fsl_shw_read_key</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *key_info, uint8_t *key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#g04b843efcdaff46f5f0fb32af616abab">fsl_shw_extract_key</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *key_info, uint8_t *covered_key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#g7e44d178dd7655cfaa9b1eba593d9085">fsl_shw_release_key</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *key_info)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#gf01391715c9ed9aa0b2da64cd82dc846">fsl_shw_gen_random_pf_key</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opfuns.html#gcde222026827ba5510acd343c931f8e7">fsl_shw_read_tamper_event</a> (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *user_ctx, <a class="el" href="shw__driver_8h.html#b61ae53f0c565bd574b08520acce8fbb">fsl_shw_tamper_t</a> *tamperp, uint64_t *timestampp)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
These functions request that the underlying hardware perform cryptographic operations. They are the heart of the API. <hr><h2>Function Documentation</h2>
<a class="anchor" name="g80cd0b9ba062845ef4eeac5413a0d579"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_add_entropy" ref="g80cd0b9ba062845ef4eeac5413a0d579" args="(fsl_shw_uco_t *user_ctx, uint32_t length, uint8_t *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_add_entropy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add entropy to random number generator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Number of bytes at <em>data</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Entropy to add to random number generator.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Add entropy to a random number generator<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8d0b815bbd579551a2f9be604474e474"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_auth_decrypt" ref="g8d0b815bbd579551a2f9be604474e474" args="(fsl_shw_uco_t *user_ctx, fsl_shw_acco_t *auth_ctx, fsl_shw_sko_t *cipher_key_info, fsl_shw_sko_t *auth_key_info, uint32_t auth_data_length, const uint8_t *auth_data, uint32_t payload_length, const uint8_t *ct, const uint8_t *auth_value, uint8_t *payload)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_auth_decrypt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__acco__t.html">fsl_shw_acco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>auth_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cipher_key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>auth_key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>auth_data_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>auth_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>payload_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>auth_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Authenticate and decrypt a (CCM) stream. 
<p>
Perform Authentication-Decryption in Cipher + Hash.<p>
This function will perform a one-shot decryption of a data stream as well as authenticate the authentication value. This is a one-shot function, so all of the <em>auth_data</em> and the total message <em>payload</em> must passed in one call. This also means that the flags in the <em>auth_ctx</em> must be <a class="el" href="group__lnkflags.html#ggc3383b674146753aa12cd9f1ec39070403228491701cd6f498c1e27e4149f423">FSL_ACCO_CTX_INIT</a> and <a class="el" href="group__lnkflags.html#ggc3383b674146753aa12cd9f1ec3907046dfd2fead30ddec94005a1cdace57c08">FSL_ACCO_CTX_FINALIZE</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_ctx</em>&nbsp;</td><td>Controlling object for Authenticate-decrypt. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cipher_key_info</em>&nbsp;</td><td>The key being used for the cipher part of this operation. In CCM mode, this key is used for both parts. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_key_info</em>&nbsp;</td><td>The key being used for the authentication part of this operation. In CCM mode, this key is ignored and may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_data_length</em>&nbsp;</td><td>Length, in octets, of <em>auth_data</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_data</em>&nbsp;</td><td>Data to be authenticated but not decrypted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_length</em>&nbsp;</td><td>Length, in octets, of <em>ct</em> and <em>pt</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ct</em>&nbsp;</td><td>Pointer to the encrypted input stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_value</em>&nbsp;</td><td>The (encrypted) authentication value which will be authenticated. This is the same data as the (output) <em>auth_value</em> argument to <a class="el" href="shw__driver_8h.html#g7e450fe979f833b3cc4da2c85c24b26e" title="Generate a (CCM) auth code and encrypt the payload.">fsl_shw_gen_encrypt()</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>payload</em>&nbsp;</td><td>Pointer to where the plaintext resulting from the decryption will be stored.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>The user's context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_ctx</em>&nbsp;</td><td>Info on this Auth operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cipher_key_info</em>&nbsp;</td><td>Key to encrypt payload </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_key_info</em>&nbsp;</td><td>(unused - same key in CCM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_data_length</em>&nbsp;</td><td>Length in bytes of <em>auth_data</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_data</em>&nbsp;</td><td>Any auth-only data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_length</em>&nbsp;</td><td>Length in bytes of <em>payload</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ct</em>&nbsp;</td><td>The encrypted data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_value</em>&nbsp;</td><td>The authentication code to validate </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>payload</em>&nbsp;</td><td>The location to store decrypted data</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd6f5a7a2e28817cf9e7d85d032826ef6"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_establish_key" ref="gd6f5a7a2e28817cf9e7d85d032826ef6" args="(fsl_shw_uco_t *user_ctx, fsl_shw_sko_t *key_info, fsl_shw_key_wrap_t establish_type, const uint8_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_establish_key           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="shw__driver_8h.html#2252cb841bd6ad23317850ff3f21575c">fsl_shw_key_wrap_t</a>&nbsp;</td>
          <td class="paramname"> <em>establish_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Establish the key in a protected location, which can be the system keystore, user keystore, or (on platforms that support it) as a Platform Key.<p>
By default, keys initialized with <a class="el" href="shw__driver_8h.html#433483ef7c4a533e7189587855be22ee">fsl_shw_sko_init()</a> will be placed into the system keystore. The user can cause the key to be established in a user keystore by first calling fsl_shw_sko_set_keystore() on the key. Normally, keys in the system keystore can only be used for hardware encrypt or decrypt operations, however if the <a class="el" href="group__lnkflags.html#gg6610116bf3969ba8ba9e32a508768860d0932b1b0fcd022ae0fa6b109e893c44">FSL_SKO_KEY_SW_KEY</a> flag is applied using <a class="el" href="shw__driver_8h.html#faafc75e85b6ffc5b8395c604d7faa26">fsl_shw_sko_set_flags()</a>, the key will be established as a software key, which can then be read out using <a class="el" href="group__opfuns.html#g3dab929899d17019f25fe84411fa17d4">fsl_shw_read_key()</a>.<p>
Keys initialized with <a class="el" href="shw__driver_8h.html#57489e6fa6a03c58acfdd7e554683456">fsl_shw_sko_init_pf_key()</a> are established as a Platform Key. Their use is covered in <a class="el" href="group__glossary.html#di_sec">Hardware key-select extensions - DryIce</a>.<p>
This function only needs to be used when unwrapping a key, setting up a key which could be wrapped with a later call to <a class="el" href="group__opfuns.html#g04b843efcdaff46f5f0fb32af616abab">fsl_shw_extract_key()</a>, or setting up a key as a Platform Key. Normal cleartext keys can simply be placed into <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> key objects with <a class="el" href="shw__driver_8h.html#717e443ca9b0343337474d289d8f3806">fsl_shw_sko_set_key()</a> and used directly.<p>
The maximum key size supported for wrapped/unwrapped keys is 32 octets. (This is the maximum reasonable key length on Sahara - 32 octets for an HMAC key based on SHA-256.) The key size is determined by the <em>key_info</em>. The expected length of <em>key</em> can be determined by <a class="el" href="shw__driver_8h.html#edafad0a0e641ff7f4aeed58217f7c4e">fsl_shw_sko_calculate_wrapped_size()</a><p>
The protected key will not be available for use until this operation successfully completes.<p>
This feature is not available for all platforms, nor for all algorithms and modes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>key_info</em>&nbsp;</td><td>The information about the key to be which will be established. In the create case, the key length must be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>establish_type</em>&nbsp;</td><td>How <em>key</em> will be interpreted to establish a key for use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>If <em>establish_type</em> is <a class="el" href="group__lnkflags.html#gg2252cb841bd6ad23317850ff3f21575c11f621a225c85d3e9582306c268aef49">FSL_KEY_WRAP_UNWRAP</a>, this is the location of a wrapped key. If <em>establish_type</em> is <a class="el" href="group__lnkflags.html#gg2252cb841bd6ad23317850ff3f21575cf9dfc244f5c00c6e30a3100a3053efd5">FSL_KEY_WRAP_CREATE</a>, this parameter can be <em>NULL</em>. If <em>establish_type</em> is <a class="el" href="group__lnkflags.html#gg2252cb841bd6ad23317850ff3f21575c1aa46c40c459e74f2936c8f87e8d76e4">FSL_KEY_WRAP_ACCEPT</a>, this is the location of a plaintext key.</td></tr>
  </table>
</dl>
Place a key into a protected location for use only by cryptographic algorithms.<p>
This only needs to be used to a) unwrap a key, or b) set up a key which could be wrapped with a later call to <a class="el" href="group__opfuns.html#g04b843efcdaff46f5f0fb32af616abab">fsl_shw_extract_key()</a>. Normal cleartext keys can simply be placed into <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> key objects with <a class="el" href="shw__driver_8h.html#717e443ca9b0343337474d289d8f3806">fsl_shw_sko_set_key()</a> and used directly.<p>
The maximum key size supported for wrapped/unwrapped keys is 32 octets. (This is the maximum reasonable key length on Sahara - 32 octets for an HMAC key based on SHA-256.) The key size is determined by the <em>key_info</em>. The expected length of <em>key</em> can be determined by <a class="el" href="shw__driver_8h.html#edafad0a0e641ff7f4aeed58217f7c4e">fsl_shw_sko_calculate_wrapped_size()</a><p>
The protected key will not be available for use until this operation successfully completes.<p>
This feature is not available for all platforms, nor for all algorithms and modes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>key_info</em>&nbsp;</td><td>The information about the key to be which will be established. In the create case, the key length must be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>establish_type</em>&nbsp;</td><td>How <em>key</em> will be interpreted to establish a key for use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>If <em>establish_type</em> is <a class="el" href="group__lnkflags.html#gg2252cb841bd6ad23317850ff3f21575c11f621a225c85d3e9582306c268aef49">FSL_KEY_WRAP_UNWRAP</a>, this is the location of a wrapped key. If <em>establish_type</em> is <a class="el" href="group__lnkflags.html#gg2252cb841bd6ad23317850ff3f21575cf9dfc244f5c00c6e30a3100a3053efd5">FSL_KEY_WRAP_CREATE</a>, this parameter can be <em>NULL</em>. If <em>establish_type</em> is <a class="el" href="group__lnkflags.html#gg2252cb841bd6ad23317850ff3f21575c1aa46c40c459e74f2936c8f87e8d76e4">FSL_KEY_WRAP_ACCEPT</a>, this is the location of a plaintext key.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g04b843efcdaff46f5f0fb32af616abab"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_extract_key" ref="g04b843efcdaff46f5f0fb32af616abab" args="(fsl_shw_uco_t *user_ctx, fsl_shw_sko_t *key_info, uint8_t *covered_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_extract_key           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>covered_key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wrap a key and retrieve the wrapped value.<p>
A wrapped key is a key that has been cryptographically obscured. It is only able to be used with keys that have been established by <a class="el" href="group__opfuns.html#gd6f5a7a2e28817cf9e7d85d032826ef6">fsl_shw_establish_key()</a>.<p>
For keys established in the system or user keystore, this function will also release the key (see <a class="el" href="group__opfuns.html#g7e44d178dd7655cfaa9b1eba593d9085">fsl_shw_release_key()</a>) so that it must be re- established before reuse. This function will not release keys that are established as a Platform Key, so a call to <a class="el" href="group__opfuns.html#g7e44d178dd7655cfaa9b1eba593d9085">fsl_shw_release_key()</a> is necessary to release those keys.<p>
This feature is not available for all platforms, nor for all algorithms and modes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td>The information about the key to be deleted. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>covered_key</em>&nbsp;</td><td>The location to store the wrapped key. (This size is based upon the maximum key size of 32 octets).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Wrap a key and retrieve the wrapped value.<p>
A wrapped key is a key that has been cryptographically obscured. It is only able to be used with <a class="el" href="group__opfuns.html#gd6f5a7a2e28817cf9e7d85d032826ef6">fsl_shw_establish_key()</a>.<p>
This function will also release the key (see <a class="el" href="group__opfuns.html#g7e44d178dd7655cfaa9b1eba593d9085">fsl_shw_release_key()</a>) so that it must be re-established before reuse.<p>
This feature is not available for all platforms, nor for all algorithms and modes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td>The information about the key to be deleted. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>covered_key</em>&nbsp;</td><td>The location to store the 48-octet wrapped key. (This size is based upon the maximum key size of 32 octets).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7e450fe979f833b3cc4da2c85c24b26e"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_gen_encrypt" ref="g7e450fe979f833b3cc4da2c85c24b26e" args="(fsl_shw_uco_t *user_ctx, fsl_shw_acco_t *auth_ctx, fsl_shw_sko_t *cipher_key_info, fsl_shw_sko_t *auth_key_info, uint32_t auth_data_length, const uint8_t *auth_data, uint32_t payload_length, const uint8_t *payload, uint8_t *ct, uint8_t *auth_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_gen_encrypt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__acco__t.html">fsl_shw_acco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>auth_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cipher_key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>auth_key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>auth_data_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>auth_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>payload_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>auth_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a (CCM) auth code and encrypt the payload. 
<p>
Perform Generation-Encryption by doing a Cipher and a Hash.<p>
Generate the authentication value <em>auth_value</em> as well as encrypt the <em>payload</em> into <em>ct</em> (the ciphertext). This is a one-shot function, so all of the <em>auth_data</em> and the total message <em>payload</em> must passed in one call. This also means that the flags in the <em>auth_ctx</em> must be <a class="el" href="group__lnkflags.html#ggc3383b674146753aa12cd9f1ec39070403228491701cd6f498c1e27e4149f423">FSL_ACCO_CTX_INIT</a> and <a class="el" href="group__lnkflags.html#ggc3383b674146753aa12cd9f1ec3907046dfd2fead30ddec94005a1cdace57c08">FSL_ACCO_CTX_FINALIZE</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_ctx</em>&nbsp;</td><td>Controlling object for Authenticate-decrypt. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cipher_key_info</em>&nbsp;</td><td>The key being used for the cipher part of this operation. In CCM mode, this key is used for both parts. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_key_info</em>&nbsp;</td><td>The key being used for the authentication part of this operation. In CCM mode, this key is ignored and may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_data_length</em>&nbsp;</td><td>Length, in octets, of <em>auth_data</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_data</em>&nbsp;</td><td>Data to be authenticated but not encrypted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_length</em>&nbsp;</td><td>Length, in octets, of <em>payload</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>Pointer to the plaintext to be encrypted. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ct</em>&nbsp;</td><td>Pointer to the where the encrypted <em>payload</em> will be stored. Must be <em>payload_length</em> octets long. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>auth_value</em>&nbsp;</td><td>Pointer to where the generated authentication field will be stored. Must be as many octets as indicated by MAC length in the <em>function_ctx</em>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
This is a very complicated function. Seven (or eight) descriptors are required to perform a CCM calculation.<p>
First: Load CTR0 and key.<p>
Second: Run an octet of data through to bump to CTR1. (This could be done in software, but software will have to bump and later decrement - or copy and bump.<p>
Third: (in Virtio) Load a descriptor with data of zeros for CBC IV.<p>
Fourth: Run any (optional) "additional data" through the CBC-mode portion of the algorithm.<p>
Fifth: Run the payload through in CCM mode.<p>
Sixth: Extract the unencrypted MAC.<p>
Seventh: Load CTR0.<p>
Eighth: Encrypt the MAC.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>The user's context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_ctx</em>&nbsp;</td><td>Info on this Auth operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cipher_key_info</em>&nbsp;</td><td>Key to encrypt payload </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_key_info</em>&nbsp;</td><td>(unused - same key in CCM) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_data_length</em>&nbsp;</td><td>Length in bytes of <em>auth_data</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_data</em>&nbsp;</td><td>Any auth-only data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_length</em>&nbsp;</td><td>Length in bytes of <em>payload</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>The data to encrypt </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ct</em>&nbsp;</td><td>The location to store encrypted data </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>auth_value</em>&nbsp;</td><td>The location to store authentication code</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf01391715c9ed9aa0b2da64cd82dc846"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_gen_random_pf_key" ref="gf01391715c9ed9aa0b2da64cd82dc846" args="(fsl_shw_uco_t *user_ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_gen_random_pf_key           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cause the hardware to create a new random key for use by the secure memory encryption hardware.<p>
Have the hardware use the secure hardware random number generator to load a new secret key into the system's Random Key register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Cause the hardware to create a new random key for secure memory use.<p>
Have the hardware use the secure hardware random number generator to load a new secret key into the hardware random key register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Cause the hardware to create a new random key for use by the secure memory encryption hardware.<p>
Have the hardware use the secure hardware random number generator to load a new secret key into the system's Random Key register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

<p>References <a class="el" href="shw__driver_8h-source.html#l00159">FSL_RETURN_ERROR_S</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2aba93b3238c1ead9a1e3fc5f4f2d619"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_get_random" ref="g2aba93b3238c1ead9a1e3fc5f4f2d619" args="(fsl_shw_uco_t *user_ctx, uint32_t length, uint8_t *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_get_random           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get random data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of octets of <em>data</em> being requested. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to a location of <em>length</em> octets to where random data will be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Get random data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of octets of <em>data</em> being requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to a location of <em>length</em> octets to where random data will be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FSL_RETURN_NO_RESOURCE_S A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. FSL_RETURN_OK_S</dd></dl>
Get random data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of octets of <em>data</em> being requested. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to a location of <em>length</em> octets to where random data will be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Get random data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of octets of <em>data</em> being requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to a location of <em>length</em> octets to where random data will be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FSL_RETURN_NO_RESOURCE_S A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. FSL_RETURN_OK_S</dd></dl>
Get a random number<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga9092309757f63584e6d05b133c5ef6c"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_hash" ref="ga9092309757f63584e6d05b133c5ef6c" args="(fsl_shw_uco_t *user_ctx, fsl_shw_hco_t *hash_ctx, const uint8_t *msg, uint32_t length, uint8_t *result, uint32_t result_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_hash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__hco__t.html">fsl_shw_hco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>hash_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>result_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hash a stream of data with a cryptographic hash algorithm.<p>
The flags in the <em>hash_ctx</em> control the operation of this function.<p>
Hashing functions work on 64 octets of message at a time. Therefore, when any partial hashing of a long message is performed, the message <em>length</em> of each segment must be a multiple of 64. When ready to <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405f74d3ab0d836491eb4ce636f7b36fa4e9">FSL_HASH_FLAGS_FINALIZE</a> the hash, the <em>length</em> may be any value.<p>
With the <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405f037e7715cb21f40587762a1c5cfd2542">FSL_HASH_FLAGS_INIT</a> and <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405f74d3ab0d836491eb4ce636f7b36fa4e9">FSL_HASH_FLAGS_FINALIZE</a> flags on, a one-shot complete hash, including padding, will be performed. The <em>length</em> may be any value.<p>
The first octets of a data stream can be hashed by setting the <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405f037e7715cb21f40587762a1c5cfd2542">FSL_HASH_FLAGS_INIT</a> and <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405f56452f5581bfb2dac4a5c123f117504f">FSL_HASH_FLAGS_SAVE</a> flags. The <em>length</em> must be a multiple of 64.<p>
The flag <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405fd7ee88c8db92693fcd580fcccf5c2069">FSL_HASH_FLAGS_LOAD</a> is used to load a context previously saved by <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405f56452f5581bfb2dac4a5c123f117504f">FSL_HASH_FLAGS_SAVE</a>. The two in combination will allow a (multiple-of-64 octets) 'middle sequence' of the data stream to be hashed with the beginning. The <em>length</em> must again be a multiple of 64.<p>
Since the flag <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405fd7ee88c8db92693fcd580fcccf5c2069">FSL_HASH_FLAGS_LOAD</a> is used to load a context previously saved by <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405f56452f5581bfb2dac4a5c123f117504f">FSL_HASH_FLAGS_SAVE</a>, the <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405fd7ee88c8db92693fcd580fcccf5c2069">FSL_HASH_FLAGS_LOAD</a> and <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405f74d3ab0d836491eb4ce636f7b36fa4e9">FSL_HASH_FLAGS_FINALIZE</a> flags, used together, can be used to finish the stream. The <em>length</em> may be any value.<p>
If the user program wants to do the padding for the hash, it can leave off the <a class="el" href="group__lnkflags.html#gg73c4fb97efd53a82280abc65a8e2405f74d3ab0d836491eb4ce636f7b36fa4e9">FSL_HASH_FLAGS_FINALIZE</a> flag. The <em>length</em> must then be a multiple of 64 octets.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>hash_ctx</em>&nbsp;</td><td>Hashing algorithm and state of the cipher. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to the data to be hashed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length, in octets, of the <em>msg</em>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>result</em>&nbsp;</td><td>If not null, pointer to where to store the hash digest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result_len</em>&nbsp;</td><td>Number of octets to store in <em>result</em>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gac83e16693bcfba44b4f7669c17c8e5a"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_hmac" ref="gac83e16693bcfba44b4f7669c17c8e5a" args="(fsl_shw_uco_t *user_ctx, fsl_shw_sko_t *key_info, fsl_shw_hmco_t *hmac_ctx, const uint8_t *msg, uint32_t length, uint8_t *result, uint32_t result_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_hmac           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__hmco__t.html">fsl_shw_hmco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>hmac_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>result_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Continue, finalize, or one-shot an HMAC operation.<p>
There are a number of ways to use this function. The flags in the <em>hmac_ctx</em> object will determine what operations occur.<p>
If <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7dc0dbf682f352a32e7cf41a6e8fd3d53d">FSL_HMAC_FLAGS_INIT</a> is set, then the hash will be started either from the <em>key_info</em>, or from the precomputed inner hash value in the <em>hmac_ctx</em>, depending on the value of <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7d974141eb47bc561b51c58f9af526ca01">FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT</a>.<p>
If, instead, <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7d5c0487a8c77ee02d68438595a56d3289">FSL_HMAC_FLAGS_LOAD</a> is set, then the hash will be continued from the ongoing inner hash computation in the <em>hmac_ctx</em>.<p>
If <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7d746b07b6d98949f68a391d8ef95e0578">FSL_HMAC_FLAGS_FINALIZE</a> are set, then the <em>msg</em> will be padded, hashed, the outer hash will be performed, and the <em>result</em> will be generated.<p>
If the <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7d0365b584b54cb60bb73eec298a4fb656">FSL_HMAC_FLAGS_SAVE</a> flag is set, then the (ongoing or final) digest value will be stored in the ongoing inner hash computation field of the <em>hmac_ctx</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td>If <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7dc0dbf682f352a32e7cf41a6e8fd3d53d">FSL_HMAC_FLAGS_INIT</a> is set in the <em>hmac_ctx</em>, this is the key being used in this operation, and the IPAD. If <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7dc0dbf682f352a32e7cf41a6e8fd3d53d">FSL_HMAC_FLAGS_INIT</a> is set in the <em>hmac_ctx</em> and <em>key_info</em> is NULL, then <a class="el" href="group__opfuns.html#g68cfe8ee1d53a1759e961416ea74656d">fsl_shw_hmac_precompute()</a> has been used to populate the <em>inner_precompute</em> and <em>outer_precompute</em> contexts. If <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7dc0dbf682f352a32e7cf41a6e8fd3d53d">FSL_HMAC_FLAGS_INIT</a> is not set, this parameter is ignored.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>hmac_ctx</em>&nbsp;</td><td>The context which controls, by its flags and algorithm, the operation of this function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to the message to be hashed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length, in octets, of the <em>msg</em>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>result</em>&nbsp;</td><td>Pointer, of <em>result_len</em> octets, to where to store the HMAC. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result_len</em>&nbsp;</td><td>Length of <em>result</em> buffer.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Get the hmac<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>Info for acquiring memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hmac_ctx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result_len</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Continue, finalize, or one-shot an HMAC operation.<p>
There are a number of ways to use this function. The flags in the <em>hmac_ctx</em> object will determine what operations occur.<p>
If <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7dc0dbf682f352a32e7cf41a6e8fd3d53d">FSL_HMAC_FLAGS_INIT</a> is set, then the hash will be started either from the <em>key_info</em>, or from the precomputed inner hash value in the <em>hmac_ctx</em>, depending on the value of <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7d974141eb47bc561b51c58f9af526ca01">FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT</a>.<p>
If, instead, <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7d5c0487a8c77ee02d68438595a56d3289">FSL_HMAC_FLAGS_LOAD</a> is set, then the hash will be continued from the ongoing inner hash computation in the <em>hmac_ctx</em>.<p>
If <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7d746b07b6d98949f68a391d8ef95e0578">FSL_HMAC_FLAGS_FINALIZE</a> are set, then the <em>msg</em> will be padded, hashed, the outer hash will be performed, and the <em>result</em> will be generated.<p>
If the <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7d0365b584b54cb60bb73eec298a4fb656">FSL_HMAC_FLAGS_SAVE</a> flag is set, then the (ongoing or final) digest value will be stored in the ongoing inner hash computation field of the <em>hmac_ctx</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td>If <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7dc0dbf682f352a32e7cf41a6e8fd3d53d">FSL_HMAC_FLAGS_INIT</a> is set in the <em>hmac_ctx</em>, this is the key being used in this operation, and the IPAD. If <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7dc0dbf682f352a32e7cf41a6e8fd3d53d">FSL_HMAC_FLAGS_INIT</a> is set in the <em>hmac_ctx</em> and <em>key_info</em> is NULL, then <a class="el" href="group__opfuns.html#g68cfe8ee1d53a1759e961416ea74656d">fsl_shw_hmac_precompute()</a> has been used to populate the <em>inner_precompute</em> and <em>outer_precompute</em> contexts. If <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7dc0dbf682f352a32e7cf41a6e8fd3d53d">FSL_HMAC_FLAGS_INIT</a> is not set, this parameter is ignored.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>hmac_ctx</em>&nbsp;</td><td>The context which controls, by its flags and algorithm, the operation of this function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to the message to be hashed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length, in octets, of the <em>msg</em>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>result</em>&nbsp;</td><td>Pointer, of <em>result_len</em> octets, to where to store the HMAC. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result_len</em>&nbsp;</td><td>Length of <em>result</em> buffer.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Get the hmac<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>Info for acquiring memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hmac_ctx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result_len</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g68cfe8ee1d53a1759e961416ea74656d"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_hmac_precompute" ref="g68cfe8ee1d53a1759e961416ea74656d" args="(fsl_shw_uco_t *user_ctx, fsl_shw_sko_t *key_info, fsl_shw_hmco_t *hmac_ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_hmac_precompute           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__hmco__t.html">fsl_shw_hmco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>hmac_ctx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Precompute the Key hashes for an HMAC operation.<p>
This function may be used to calculate the inner and outer precomputes, which are the hash contexts resulting from hashing the XORed key for the 'inner hash' and the 'outer hash', respectively, of the HMAC function.<p>
After execution of this function, the <em>hmac_ctx</em> will contain the precomputed inner and outer contexts, so that they may be used by <a class="el" href="group__opfuns.html#gac83e16693bcfba44b4f7669c17c8e5a">fsl_shw_hmac()</a>. The flags of <em>hmac_ctx</em> will be updated with <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7d974141eb47bc561b51c58f9af526ca01">FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT</a> to mark their presence. In addition, the <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7dc0dbf682f352a32e7cf41a6e8fd3d53d">FSL_HMAC_FLAGS_INIT</a> flag will be set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td>The key being used in this operation. Key must be 1 to 64 octets long. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>hmac_ctx</em>&nbsp;</td><td>The context which controls, by its flags and algorithm, the operation of this function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Get the precompute information<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hmac_ctx</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Precompute the Key hashes for an HMAC operation.<p>
This function may be used to calculate the inner and outer precomputes, which are the hash contexts resulting from hashing the XORed key for the 'inner hash' and the 'outer hash', respectively, of the HMAC function.<p>
After execution of this function, the <em>hmac_ctx</em> will contain the precomputed inner and outer contexts, so that they may be used by <a class="el" href="group__opfuns.html#gac83e16693bcfba44b4f7669c17c8e5a">fsl_shw_hmac()</a>. The flags of <em>hmac_ctx</em> will be updated with <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7d974141eb47bc561b51c58f9af526ca01">FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT</a> to mark their presence. In addition, the <a class="el" href="group__lnkflags.html#ggb23e5dffdc28bd12e7233971e3fd8a7dc0dbf682f352a32e7cf41a6e8fd3d53d">FSL_HMAC_FLAGS_INIT</a> flag will be set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td>The key being used in this operation. Key must be 1 to 64 octets long. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>hmac_ctx</em>&nbsp;</td><td>The context which controls, by its flags and algorithm, the operation of this function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Get the precompute information<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hmac_ctx</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3dab929899d17019f25fe84411fa17d4"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_read_key" ref="g3dab929899d17019f25fe84411fa17d4" args="(fsl_shw_uco_t *user_ctx, fsl_shw_sko_t *key_info, uint8_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_read_key           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read the key value from a key object.<p>
Only a key marked as a software key (<a class="el" href="group__lnkflags.html#gg6610116bf3969ba8ba9e32a508768860d0932b1b0fcd022ae0fa6b109e893c44">FSL_SKO_KEY_SW_KEY</a>) can be read with this call. It has no effect on the status of the key store.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td>The referenced key. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>The location to store the key value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gcde222026827ba5510acd343c931f8e7"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_read_tamper_event" ref="gcde222026827ba5510acd343c931f8e7" args="(fsl_shw_uco_t *user_ctx, fsl_shw_tamper_t *tamperp, uint64_t *timestampp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_read_tamper_event           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="shw__driver_8h.html#b61ae53f0c565bd574b08520acce8fbb">fsl_shw_tamper_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tamperp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>timestampp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the detected tamper event.<p>
Note that if more than one event was detected, this routine will only ever return one of them.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tamperp</em>&nbsp;</td><td>Location to store the tamper information. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>timestampp</em>&nbsp;</td><td>Locate to store timestamp from hardwhare when an event was detected.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> (for instance, if the platform is not in a fail state. </dd></dl>

<p>References <a class="el" href="shw__driver_8h-source.html#l00163">FSL_RETURN_NO_RESOURCE_S</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7e44d178dd7655cfaa9b1eba593d9085"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_release_key" ref="g7e44d178dd7655cfaa9b1eba593d9085" args="(fsl_shw_uco_t *user_ctx, fsl_shw_sko_t *key_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_release_key           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key_info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
De-establish a key so that it can no longer be accessed.<p>
The key will need to be re-established before it can again be used.<p>
This feature is not available for all platforms, nor for all algorithms and modes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td>The information about the key to be deleted.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb4e80317d10ebeef1ffeef80668c9ccd"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_symmetric_decrypt" ref="gb4e80317d10ebeef1ffeef80668c9ccd" args="(fsl_shw_uco_t *user_ctx, fsl_shw_sko_t *key_info, fsl_shw_scco_t *sym_ctx, uint32_t length, const uint8_t *ct, uint8_t *pt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_symmetric_decrypt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__scco__t.html">fsl_shw_scco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>sym_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>pt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decrypt a stream of data with a symmetric-key algorithm.<p>
In ARC4, and also in <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a74553b37260994ad285bdfea3eebfba92">FSL_SYM_MODE_CBC</a> and <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a71f390bc3ca01fe5c07d5867e406b0469">FSL_SYM_MODE_CTR</a> modes, the flags of the <em>sym_ctx</em> object will control part of the operation of this function. The <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e246d0248ea2eefb486f1043ff2b41f29b">FSL_SYM_CTX_INIT</a> flag means that there is no context info in the object. The <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e20aa2180f0c65584840235f0358445f82">FSL_SYM_CTX_LOAD</a> means to use information in the <em>sym_ctx</em> at the start of the operation, and the <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e2766311abf95d38a6a94bcdd976ea3bb7">FSL_SYM_CTX_SAVE</a> flag means to update the object's context information after the operation has been performed.<p>
All of the data for an operation can be run through at once using the <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e246d0248ea2eefb486f1043ff2b41f29b">FSL_SYM_CTX_INIT</a> or <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e20aa2180f0c65584840235f0358445f82">FSL_SYM_CTX_LOAD</a> flags, as appropriate, and then using a <em>length</em> for the whole of the data.<p>
If a <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e2766311abf95d38a6a94bcdd976ea3bb7">FSL_SYM_CTX_SAVE</a> flag were added, an additional call to the function would "pick up" where the previous call left off, allowing the user to perform the larger function in smaller steps.<p>
In <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a74553b37260994ad285bdfea3eebfba92">FSL_SYM_MODE_CBC</a> and <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a787733195c1db7c10e60bdf0e5cda0a7e">FSL_SYM_MODE_ECB</a> modes, the <em>length</em> must always be a multiple of the block size for the algorithm being used. For proper operation in <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a71f390bc3ca01fe5c07d5867e406b0469">FSL_SYM_MODE_CTR</a> mode, the <em>length</em> must be a multiple of the block size until the last operation on the total octet stream.<p>
Some users of ARC4 may want to compute the context (S-Box and pointers) from the key before any data is available. This may be done by running this function with a <em>length</em> of zero, with the <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e246d0248ea2eefb486f1043ff2b41f29b">FSL_SYM_CTX_INIT</a> &amp; <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e2766311abf95d38a6a94bcdd976ea3bb7">FSL_SYM_CTX_SAVE</a> flags on in the <em>sym_ctx</em>. Subsequent operations would then run as normal with the load &amp; save flags. Note that they key object is still required.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td>The key and algorithm being used in this operation. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sym_ctx</em>&nbsp;</td><td>Info on cipher mode, state of the cipher. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length, in octets, of the ct (and pt). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ct</em>&nbsp;</td><td>pointer to ciphertext to be decrypted. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pt</em>&nbsp;</td><td>pointer to where to store the resulting plaintext.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a></dd></dl>
Compute symmetric decryption<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sym_ctx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pt</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ct</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbf1cb1bd38cbed4ef6f028dd11f2a821"></a><!-- doxytag: member="fsl_shw.h::fsl_shw_symmetric_encrypt" ref="gbf1cb1bd38cbed4ef6f028dd11f2a821" args="(fsl_shw_uco_t *user_ctx, fsl_shw_sko_t *key_info, fsl_shw_scco_t *sym_ctx, uint32_t length, const uint8_t *pt, uint8_t *ct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shw__driver_8h.html#4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a> fsl_shw_symmetric_encrypt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>user_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsl__shw__scco__t.html">fsl_shw_scco_t</a> *&nbsp;</td>
          <td class="paramname"> <em>sym_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>ct</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encrypt a stream of data with a symmetric-key algorithm.<p>
In ARC4, and also in <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a74553b37260994ad285bdfea3eebfba92">FSL_SYM_MODE_CBC</a> and <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a71f390bc3ca01fe5c07d5867e406b0469">FSL_SYM_MODE_CTR</a> modes, the flags of the <em>sym_ctx</em> object will control part of the operation of this function. The <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e246d0248ea2eefb486f1043ff2b41f29b">FSL_SYM_CTX_INIT</a> flag means that there is no context info in the object. The <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e20aa2180f0c65584840235f0358445f82">FSL_SYM_CTX_LOAD</a> means to use information in the <em>sym_ctx</em> at the start of the operation, and the <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e2766311abf95d38a6a94bcdd976ea3bb7">FSL_SYM_CTX_SAVE</a> flag means to update the object's context information after the operation has been performed.<p>
All of the data for an operation can be run through at once using the <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e246d0248ea2eefb486f1043ff2b41f29b">FSL_SYM_CTX_INIT</a> or <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e20aa2180f0c65584840235f0358445f82">FSL_SYM_CTX_LOAD</a> flags, as appropriate, and then using a <em>length</em> for the whole of the data.<p>
If a <a class="el" href="group__lnkflags.html#gg786b0e25ce21a6f3b60dfc26db04e1e2766311abf95d38a6a94bcdd976ea3bb7">FSL_SYM_CTX_SAVE</a> flag were added, an additional call to the function would "pick up" where the previous call left off, allowing the user to perform the larger function in smaller steps.<p>
In <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a74553b37260994ad285bdfea3eebfba92">FSL_SYM_MODE_CBC</a> and <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a787733195c1db7c10e60bdf0e5cda0a7e">FSL_SYM_MODE_ECB</a> modes, the <em>length</em> must always be a multiple of the block size for the algorithm being used. For proper operation in <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a71f390bc3ca01fe5c07d5867e406b0469">FSL_SYM_MODE_CTR</a> mode, the <em>length</em> must be a multiple of the block size until the last operation on the total octet stream.<p>
Some users of ARC4 may want to compute the context (S-Box and pointers) from the key before any data is available. This may be done by running this function with a <em>length</em> of zero, with the init &amp; save flags flags on in the <em>sym_ctx</em>. Subsequent operations would then run as normal with the load and save flags. Note that they key object is still required.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td>A user context from <a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td>Key and algorithm being used for this operation. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sym_ctx</em>&nbsp;</td><td>Info on cipher mode, state of the cipher. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length, in octets, of the pt (and ct). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pt</em>&nbsp;</td><td>pointer to plaintext to be encrypted. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ct</em>&nbsp;</td><td>pointer to where to store the resulting ciphertext.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>.</dd></dl>
Compute symmetric encryption<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_ctx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key_info</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sym_ctx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pt</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ct</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A return code of type <a class="el" href="group__lnkflags.html#g4d2b660905d31e2f8d24ad6f13150b35">fsl_shw_return_t</a>. </dd></dl>

</div>
</div><p>
</div>
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<Title>footer</Title>
</HEAD>
<BODY>
</ul>
</ul>
</ul>
</ul>
<hr size="1">
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1">
  <tr>
    <td width="50%"><small>&nbsp; Freescale Semiconductor, Inc., 2007.&nbsp; 
    All rights reserved.<br>
    </small><FONT COLOR="#FF0000"><small>Freescale Confidential Proprietary<br>
    </small></FONT><small><FONT COLOR="#FF0000">NDA Required</FONT></small></td>
    <td width="50%"><small>
<a href="http://www.doxygen.org/index.html">
<img src="Freescale25.png" alt="doxygen" align="right" border="0" width="129" height="48"></a></small></td>
  </tr>
</table>
<address style="align: right;">&nbsp;</address>
</body>
</html>
