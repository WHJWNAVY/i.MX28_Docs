<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MXC Linux BSP: Glossary</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>Glossary</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
<h2><a class="anchor" name="intro_sec">
Introduction</a></h2>
This is the interface definition for the Freescale Security Hardware API (FSL SHW API) for User Mode and Kernel Mode to access Freescale Security Hardware components for cryptographic acceleration. The API is intended to provide cross-platform access to security hardware components of Freescale.<p>
This documentation has not been approved, and should not be taken to mean anything definite about future direction.<p>
Some example code is provided to give some idea of usage of this API.<p>
Note: This first version has been defined around the capabilities of the Sahara2 cryptographic accelerator, and may be expanded in the future to provide support for other platforms. The Platform Capabilities Object is intended as a way to allow programs to adapt to different platforms.<p>
The i.MX25 is an example of a platform without a SAHARA but yet has capabilities supported by this API. These include <a class="el" href="group__opfuns.html#g2aba93b3238c1ead9a1e3fc5f4f2d619">fsl_shw_get_random()</a> and <a class="el" href="group__opfuns.html#g80cd0b9ba062845ef4eeac5413a0d579">fsl_shw_add_entropy()</a>, and the use of Triple-DES (TDEA) cipher algorithm (with no checking of key parity supported) in ECB and CBC modes with <a class="el" href="group__glossary.html#sym_sec">Symmetric-Key Encryption and Decryption</a>. See also the <a class="el" href="group__glossary.html#di_sec">Hardware key-select extensions - DryIce</a> for information on key handling, and <a class="el" href="group__glossary.html#td_sec">Device Tamper-Detection</a> for detection of Tamper Events. Only the random functions are available from user space on this platform.<h2><a class="anchor" name="usr_ctx">
The User Context</a></h2>
The User Context Object (<a class="el" href="structfsl__shw__uco__t.html">fsl_shw_uco_t</a>) controls the interaction between the user program and the API. It is initialized as part of user registration (<a class="el" href="shw__driver_8h.html#g67f5e2ba19ec054ff6d103530cdab73c">fsl_shw_register_user()</a>), and is part of every interaction thereafter.<h2><a class="anchor" name="pf_sec">
Platform Capabilities</a></h2>
Since this API is not tied to one specific type of hardware or even one given version of a given type of hardware, the platform capabilities object could be used by a portable program to make choices about using software instead of hardware for certain operations.<p>
See the <a class="el" href="structfsl__shw__pco__t.html" title="Platform Capability Object.">fsl_shw_pco_t</a>, returned by <a class="el" href="shw__driver_8h.html#g3f5241fea6e98432445422737a23305c">fsl_shw_get_capabilities()</a>.<p>
<a class="el" href="group__pcoops.html">Platform Context Object Operations</a> are provided to query its contents.<h2><a class="anchor" name="sym_sec">
Symmetric-Key Encryption and Decryption</a></h2>
Symmetric-Key encryption support is provided for the block cipher algorithms AES, DES, and Triple DES. Modes supported are <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a787733195c1db7c10e60bdf0e5cda0a7e">FSL_SYM_MODE_ECB</a>, <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a74553b37260994ad285bdfea3eebfba92">FSL_SYM_MODE_CBC</a>, and <a class="el" href="group__lnkflags.html#gga341b62ad687f35db7848cb1f85c46a71f390bc3ca01fe5c07d5867e406b0469">FSL_SYM_MODE_CTR</a>, though not necessarily all modes for all algorithms. There is also support for the stream cipher algorithm commonly known as ARC4.<p>
Encryption and decryption are performed by using the functions <a class="el" href="group__opfuns.html#gbf1cb1bd38cbed4ef6f028dd11f2a821">fsl_shw_symmetric_encrypt()</a> and <a class="el" href="group__opfuns.html#gb4e80317d10ebeef1ffeef80668c9ccd">fsl_shw_symmetric_decrypt()</a>, respectively. There are two objects which provide information about the operation of these functions. They are the <a class="el" href="structfsl__shw__sko__t.html">fsl_shw_sko_t</a>, to provide key and algorithm information; and the <a class="el" href="structfsl__shw__scco__t.html">fsl_shw_scco_t</a>, to provide (and store) initial context or counter value information.<p>
CCM is not supported by these functions. For information CCM support, see <a class="el" href="group__glossary.html#cmb_sec">Combined Cipher and Authentication</a>.<h2><a class="anchor" name="hash_sec">
Cryptographic Hashing</a></h2>
Hashing is performed by <a class="el" href="group__opfuns.html#ga9092309757f63584e6d05b133c5ef6c">fsl_shw_hash()</a>. Control of the function is through flags in the <a class="el" href="structfsl__shw__hco__t.html">fsl_shw_hco_t</a>. The algorithms which are supported are listed in <a class="el" href="group__lnkflags.html#g18390075437c28726003935a7be1d81b">fsl_shw_hash_alg_t</a>.<p>
The hashing function works on octet streams. If a user application needs to hash a bitstream, it will need to do its own padding of the last block.<h2><a class="anchor" name="hmac_sec">
Hashed Message Authentication Codes</a></h2>
An HMAC is a method of combining a hash and a key so that a message cannot be faked by a third party.<p>
The <a class="el" href="group__opfuns.html#gac83e16693bcfba44b4f7669c17c8e5a">fsl_shw_hmac()</a> can be used by itself for one-shot or multi-step operations, or in combination with <a class="el" href="group__opfuns.html#g68cfe8ee1d53a1759e961416ea74656d">fsl_shw_hmac_precompute()</a> to provide the ability to compute and save the beginning hashes from a key one time, and then use <a class="el" href="group__opfuns.html#gac83e16693bcfba44b4f7669c17c8e5a">fsl_shw_hmac()</a> to calculate an HMAC on each message as it is processed.<p>
The maximum key length which is directly supported by this API is 64 octets. If a longer key size is needed for HMAC, the user will have to hash the key and present the digest value as the key to be used by the HMAC functions.<h2><a class="anchor" name="rnd_sec">
Random Numbers</a></h2>
Support is available for acquiring random values from a cryptographically-strong random number generator. See <a class="el" href="group__opfuns.html#g2aba93b3238c1ead9a1e3fc5f4f2d619">fsl_shw_get_random()</a>. The function <a class="el" href="group__opfuns.html#g80cd0b9ba062845ef4eeac5413a0d579">fsl_shw_add_entropy()</a> may be used to add entropy to the random number generator.<h2><a class="anchor" name="cmb_sec">
Combined Cipher and Authentication</a></h2>
Some schemes require that messages be encrypted and that they also have an authentication code associated with the message. The function <a class="el" href="shw__driver_8h.html#g7e450fe979f833b3cc4da2c85c24b26e" title="Generate a (CCM) auth code and encrypt the payload.">fsl_shw_gen_encrypt()</a> will generate the authentication code and encrypt the message.<p>
Upon receipt of such a message, the message must be decrypted and the authentication code validated. The function <a class="el" href="shw__driver_8h.html#g8d0b815bbd579551a2f9be604474e474" title="Authenticate and decrypt a (CCM) stream.">fsl_shw_auth_decrypt()</a> will perform these steps.<p>
Only AES-CCM is supported.<h2><a class="anchor" name="wrap_sec">
Wrapped Keys</a></h2>
On platforms with a Secure Memory, the function <a class="el" href="group__opfuns.html#gd6f5a7a2e28817cf9e7d85d032826ef6">fsl_shw_establish_key()</a> can be used to place a key into the System Keystore. This key then can be used directly by the cryptographic hardware. It later then be wrapped (cryptographically obscured) by <a class="el" href="group__opfuns.html#g04b843efcdaff46f5f0fb32af616abab">fsl_shw_extract_key()</a> and stored for later use. If a software key (<a class="el" href="group__lnkflags.html#gg6610116bf3969ba8ba9e32a508768860d0932b1b0fcd022ae0fa6b109e893c44">FSL_SKO_KEY_SW_KEY</a>) was established, then its value can be retrieved with a call to <a class="el" href="group__opfuns.html#g3dab929899d17019f25fe84411fa17d4">fsl_shw_read_key()</a>.<p>
The wrapping and unwrapping functions provide security against unauthorized use and detection of tampering.<p>
The functions can also be used with a User Keystore.<h2><a class="anchor" name="smalloc_sec">
Secure Memory Allocation</a></h2>
On platforms with multiple partitions of Secure Memory, the function <a class="el" href="shw__driver_8h.html#gb4c9ca955c5851d6f19a43f1f075beb4">fsl_shw_smalloc()</a> can be used to acquire a partition for private use. The function <a class="el" href="shw__driver_8h.html#g56b43cf25153b4aa1b73e8c8bbb0715b">fsl_shw_diminish_perms()</a> can then be used to revoke specific permissions on the partition, and <a class="el" href="shw__driver_8h.html#g783bdf3c67f51c73d310c0a36f9d59b8">fsl_shw_sfree()</a> can be used to release the partition.<h2><a class="anchor" name="keystore_sec">
User Keystore</a></h2>
User Keystore functionality is defined in <a class="el" href="fsl__shw__keystore_8h.html" title="Definition of the User Keystore API.">fsl_shw_keystore.h</a>. See <a class="el" href="user_keystore.html">User Keystore API</a> for details. This is not supported on platforms without SCC2.<h2><a class="anchor" name="di_sec">
Hardware key-select extensions - DryIce</a></h2>
Some platforms have a component called DryIce which allows the software to control which key will be used by the secure memory encryption hardware. The choices are the secret per-chip Fused (IIM) Key, an unknown, hardware- generated Random Key, a software-written Programmed Key, or the IIM Key in combination with one of the others. <a class="el" href="shw__driver_8h.html#e6fd254f73977bf72e689d7ff2748ccc">fsl_shw_pco_check_pk_supported()</a> can be used to determine whether this feature is available on the platform. The rest of this section will explain the symmetric ciphering and key operations which are available on such a platform.<p>
The function <a class="el" href="shw__driver_8h.html#57489e6fa6a03c58acfdd7e554683456">fsl_shw_sko_init_pf_key()</a> will set up a Secret Key Object to refer to one of the system's platform keys. All keys which reference a platform key must use this initialization function, including a user- provided key value. Keys which are intended for software encryption must use <a class="el" href="shw__driver_8h.html#433483ef7c4a533e7189587855be22ee">fsl_shw_sko_init()</a>.<p>
To change the setting of the Programmed Key of the DryIce module, <a class="el" href="group__opfuns.html#gd6f5a7a2e28817cf9e7d85d032826ef6">fsl_shw_establish_key()</a> must be called with a platform key object of type <a class="el" href="group__lnkflags.html#ggeb5607a9823127b6e0936d021067a6c8b76ed09b2d710c8e0e60d0f9457e2e6d">FSL_SHW_PF_KEY_PRG</a> or <a class="el" href="group__lnkflags.html#ggeb5607a9823127b6e0936d021067a6c8b5bedea5e4c0460625fcdfa761153599">FSL_SHW_PF_KEY_IIM_PRG</a>. The key will be go into the PK register of DryIce and not to the keystore. Any symmetric operation which references either <a class="el" href="group__lnkflags.html#ggeb5607a9823127b6e0936d021067a6c8b76ed09b2d710c8e0e60d0f9457e2e6d">FSL_SHW_PF_KEY_PRG</a> or <a class="el" href="group__lnkflags.html#ggeb5607a9823127b6e0936d021067a6c8b5bedea5e4c0460625fcdfa761153599">FSL_SHW_PF_KEY_IIM_PRG</a> will use the current PK value (possibly modified by the secret fused IIM key). Before the Flatform Key can be changed, a call to <a class="el" href="group__opfuns.html#g7e44d178dd7655cfaa9b1eba593d9085">fsl_shw_release_key()</a> or <a class="el" href="group__opfuns.html#g04b843efcdaff46f5f0fb32af616abab">fsl_shw_extract_key()</a> must be made. Neither function will change the value in the PK registers, and further ciphering can take place.<p>
When <a class="el" href="group__opfuns.html#gd6f5a7a2e28817cf9e7d85d032826ef6">fsl_shw_establish_key()</a> is called to change the PK value, a plaintext key can be passed in with the <a class="el" href="group__lnkflags.html#gg2252cb841bd6ad23317850ff3f21575c1aa46c40c459e74f2936c8f87e8d76e4">FSL_KEY_WRAP_ACCEPT</a> argument or a previously wrapped key can be passed in with the <a class="el" href="group__lnkflags.html#gg2252cb841bd6ad23317850ff3f21575c11f621a225c85d3e9582306c268aef49">FSL_KEY_WRAP_UNWRAP</a> argument. If <a class="el" href="group__lnkflags.html#gg2252cb841bd6ad23317850ff3f21575cf9dfc244f5c00c6e30a3100a3053efd5">FSL_KEY_WRAP_CREATE</a> is passed in, then a random value will be loaded into the PK register. The PK value can be wrapped by a call to <a class="el" href="group__opfuns.html#g04b843efcdaff46f5f0fb32af616abab">fsl_shw_extract_key()</a> for later use with the <a class="el" href="group__lnkflags.html#gg2252cb841bd6ad23317850ff3f21575c11f621a225c85d3e9582306c268aef49">FSL_KEY_WRAP_UNWRAP</a> argument.<p>
As an alternative to using only the fused key for <a class="el" href="group__glossary.html#wrap_sec">Wrapped Keys</a>, <a class="el" href="group__ucoops.html#g9f003a94c7675cb82c92479be0bc9433">fsl_shw_uco_set_wrap_key()</a> can be used to select either the random key or the random key with the fused key as the key which will be used to protect the one-time value used to wrap the key. This allows for these wrapped keys to be dependent upon and therefore unrecoverable after a tamper event causes the erasure of the DryIce Random Key register.<p>
The software can request that the hardware generate a (new) Random Key for DryIce by calling <a class="el" href="shw__driver_8h.html#002044da8fecccfa09d36579dbef5e75">fsl_shw_gen_random_pf_key()</a>.<h2><a class="anchor" name="td_sec">
Device Tamper-Detection</a></h2>
Some platforms have a component which can detect certain types of tampering with the hardware. <a class="el" href="shw__driver_8h.html#9d3130996a7f9956d61df88f9abb608c">fsl_shw_read_tamper_event()</a> API will allow the retrieval of the type of event which caused a tamper-detection failure.<p>
<ul>
<li><b>AES</b> - Advanced Encryption Standard - An NIST-created block cipher originally knowns as Rijndael. </li>
<li><b>ARC4</b> - ARCFOUR - An S-Box-based OFB mode stream cipher. </li>
<li><b>CBC</b> - Cipher-Block Chaining - Each encrypted block is XORed with the result of the previous block's encryption. </li>
<li><b>CCM</b> - A way of combining CBC and CTR to perform cipher and authentication. </li>
<li><b>ciphertext</b> - <em>plaintext</em> which has been encrypted in some fashion. </li>
<li><b>context</b> - Information on the state of a cryptographic operation, excluding any key. This could include IV, Counter Value, or SBox. </li>
<li><b>CTR</b> - A mode where a counter value is encrypted and then XORed with the data. After each block, the counter value is incremented. </li>
<li><b>DES</b> - Data Encryption Standard - An 8-octet-block cipher. </li>
<li><b>ECB</b> - Electronic Codebook - A straight encryption/decryption of the data. </li>
<li><b>hash</b> - A cryptographically strong one-way function performed on data. </li>
<li><b>HMAC</b> - Hashed Message Authentication Code - A key-dependent one-way hash result, used to verify authenticity of a message. The equation for an HMAC is hash((K + A) || hash((K + B) || msg)), where K is the key, A is the constant for the outer hash, B is the constant for the inner hash, and hash is the hashing function (MD5, SHA256, etc). </li>
<li><b>IPAD</b> - In an HMAC operation, the context generated by XORing the key with a constant and then hashing that value as the first block of the inner hash. </li>
<li><b>IV</b> - An "Initial Vector" or <em>context</em> for modes like CBC. </li>
<li><b>MAC</b> - A Message Authentication Code. HMAC, hashing, and CCM all produce a MAC. </li>
<li><b>mode</b> - A way of using a cryptographic algorithm. See ECB, CBC, etc. </li>
<li><b>MD5</b> - Message Digest 5 - A one-way hash function. </li>
<li><b>plaintext</b> - Data which has not been encrypted, or has been decrypted from <em>ciphertext</em>. </li>
<li><b>OPAD</b> - In an HMAC operation, the context generated by XORing the key with a constant and then hashing that value as the first block of the outer hash. </li>
<li><b>SHA</b> - Secure Hash Algorithm - A one-way hash function. </li>
<li><b>TDES</b> - AKA <b>3DES</b> - Triple Data Encryption Standard - A method of using two or three keys and DES to perform three operations (encrypt decrypt encrypt) to create a new algorithm. </li>
<li><b>XOR</b> - Exclusive-OR. A Boolean arithmetic function. </li>
<li><b>Wrapped</b> value - A (key) which has been encrypted into an opaque datum which cannot be unwrapped (decrypted) for use except by an authorized user. Once created, the key is never visible, but may be used for other cryptographic operations. </li>
</ul>
</div>
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<Title>footer</Title>
</HEAD>
<BODY>
</ul>
</ul>
</ul>
</ul>
<hr size="1">
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1">
  <tr>
    <td width="50%"><small>©&nbsp; Freescale Semiconductor, Inc., 2007.&nbsp; 
    All rights reserved.<br>
    </small><FONT COLOR="#FF0000"><small>Freescale Confidential Proprietary<br>
    </small></FONT><small><FONT COLOR="#FF0000">NDA Required</FONT></small></td>
    <td width="50%"><small>
<a href="http://www.doxygen.org/index.html">
<img src="Freescale25.png" alt="doxygen" align="right" border="0" width="129" height="48"></a></small></td>
  </tr>
</table>
<address style="align: right;">&nbsp;</address>
</body>
</html>
