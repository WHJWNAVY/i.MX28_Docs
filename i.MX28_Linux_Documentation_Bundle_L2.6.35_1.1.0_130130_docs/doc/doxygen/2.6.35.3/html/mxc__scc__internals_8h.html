<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MXC Linux BSP: linux/drivers/mxc/security/mxc_scc_internals.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>linux/drivers/mxc/security/mxc_scc_internals.h File Reference</h1>This is intended to be the file which contains most or all of the code or changes need to port the driver. It also includes other definitions needed by the driver.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscc__key__slot.html">scc_key_slot</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#68b9a36d69b0be4a6e7a96980212d970">SCC_KEY_SLOTS</a>&nbsp;&nbsp;&nbsp;20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#af53316da83ffdf7f3baf906cecdd9e3">SCC_MAX_KEY_SIZE</a>&nbsp;&nbsp;&nbsp;32</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#516991fd0342bd93006444a1fdd6e330">SCC_KEY_SLOT_SIZE</a>&nbsp;&nbsp;&nbsp;32</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#769bd388d3a51664ecf61e03c5f66245">SCM_NON_RESERVED_OFFSET</a>&nbsp;&nbsp;&nbsp;(SCC_KEY_SLOTS * SCC_KEY_SLOT_SIZE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#4adc1dda358a585080339b4de99d8c23">SCC_CALLBACK_SIZE</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#9239925d5defef5677f3a6f5a5425665">CRC_CCITT_START</a>&nbsp;&nbsp;&nbsp;0xFFFF</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#bb82ed96aa7d1d30d2131df742311f2b">SCC_SPIN_COUNT</a>&nbsp;&nbsp;&nbsp;1000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#d5f769fdb0725ddeadfa2e59f389d465">SCC_CIPHER_MAX_POLL_COUNT</a>&nbsp;&nbsp;&nbsp;100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#2004ecefff61cba47a9203986565cd54">SCC_READ_REGISTER</a>(offset)&nbsp;&nbsp;&nbsp;__raw_readl(scc_base+(offset))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#56cacc2575f96cb30450915a998767f4">SCC_WRITE_REGISTER</a>(offset, value)&nbsp;&nbsp;&nbsp;(void)__raw_writel(value, scc_base+(offset))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#0caef88f3a6619900f2bada5c0bc7d3c">SCC_BYTE_OFFSET</a>(bp)&nbsp;&nbsp;&nbsp;((uint32_t)(bp) % sizeof(uint32_t))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#e7a4d911046e9d482468f6c01a0f7bda">SCC_WORD_PTR</a>(bp)&nbsp;&nbsp;&nbsp;(((uint32_t)(bp)) &amp; ~(sizeof(uint32_t)-1))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#4ef50d172fae68a2d27b8756992abcd7">SCC_BLOCK_SIZE_BYTES</a>()&nbsp;&nbsp;&nbsp;scc_configuration.block_size_bytes</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#6ed9fa6b98f7086b7aa0dd9037235451">PADDING_BUFFER_MAX_BYTES</a>&nbsp;&nbsp;&nbsp;(CRC_SIZE_BYTES + sizeof(scc_block_padding))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#b3606671834386bd0e1e0eac03550c8d">CRC_SIZE_BYTES</a>&nbsp;&nbsp;&nbsp;(sizeof(<a class="el" href="mxc__scc__internals_8h.html#6b6c21dae2994d1cc6afc120b32719bf">crc_t</a>))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#4193f399cfecf510bd0f451145d5c73e">CRC_POLYNOMIAL</a>&nbsp;&nbsp;&nbsp;0x1021</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#da57803bbe4060cebe523a12bee0495d">CALC_CRC</a>(byte_value, running_crc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#485db94f63d5efeac41b2206fe0f36f7">SCC_DRIVER_PAD_CHAR</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#175a20b5baf522f0a7857caf49eee52a">SCC_DRIVER_NAME</a>&nbsp;&nbsp;&nbsp;&quot;scc&quot;</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#6b6c21dae2994d1cc6afc120b32719bf">crc_t</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#2a1b1220356b1bf049d8c5587cef776f">scc_status</a> { <br>
&nbsp;&nbsp;<a class="el" href="mxc__scc__internals_8h.html#2a1b1220356b1bf049d8c5587cef776f140dc2ab080d9d62508926c0dc3573e5">SCC_STATUS_INITIAL</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="mxc__scc__internals_8h.html#2a1b1220356b1bf049d8c5587cef776f2c7c111702c276bd0f8d271a58014643">SCC_STATUS_CHECKING</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="mxc__scc__internals_8h.html#2a1b1220356b1bf049d8c5587cef776f29ffa5534409ef79233f60a44c1e412f">SCC_STATUS_UNIMPLEMENTED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="mxc__scc__internals_8h.html#2a1b1220356b1bf049d8c5587cef776f2b4e6c8c159c4cdb563c148b62c8fd11">SCC_STATUS_OK</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="mxc__scc__internals_8h.html#2a1b1220356b1bf049d8c5587cef776f8247e670a6b244d46e43d0d18898a206">SCC_STATUS_FAILED</a>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#af554f719ba7b95a603f439f040059f7">scc_perform_callbacks</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static scc_return_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#1d1ae8faa69e54962a73210f49d83995">scc_encrypt</a> (uint32_t count_in_bytes, const uint8_t *data_in, uint32_t scm_control, uint8_t *data_out, int add_crc, unsigned long *count_out_bytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static scc_return_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mxc__scc__internals_8h.html#f6ec9a9517f46c379193450b84b64b9e">scc_decrypt</a> (uint32_t count_in_bytes, const uint8_t *data_in, uint32_t scm_control, uint8_t *data_out, int verify_crc, unsigned long *count_out_bytes)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This is intended to be the file which contains most or all of the code or changes need to port the driver. It also includes other definitions needed by the driver. 
<p>
This header file should only ever be included by scc_driver.c<p>
Compile-time flags minimally needed:<p>
<ul>
<li>Some sort of platform flag. </li>
<li>Some start-of-SCC consideration, such as SCC_BASE_ADDR</li>
</ul>
Some changes which could be made when porting this driver: <a class="el" href="mxc__scc__internals_8h.html#bb82ed96aa7d1d30d2131df742311f2b">SCC_SPIN_COUNT</a> <hr><h2>Define Documentation</h2>
<a class="anchor" name="da57803bbe4060cebe523a12bee0495d"></a><!-- doxytag: member="mxc_scc_internals.h::CALC_CRC" ref="da57803bbe4060cebe523a12bee0495d" args="(byte_value, running_crc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CALC_CRC          </td>
          <td>(</td>
          <td class="paramtype">byte_value,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">running_crc&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{                                  \
    uint8_t data;                                                            \
    data = (0xff&amp;(byte_value)) ^ (running_crc &gt;&gt; 8);                         \
    running_crc = scc_crc_lookup_table[data] ^ (running_crc &lt;&lt; 8);           \
}
</pre></div>Calculate CRC on one byte of data<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>running_crc</em>&nbsp;</td><td>A value of type crc_t where CRC is kept. This must be an rvalue and an lvalue. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byte_value</em>&nbsp;</td><td>The byte (uint8_t, char) to be put in the CRC</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div><p>
<a class="anchor" name="9239925d5defef5677f3a6f5a5425665"></a><!-- doxytag: member="mxc_scc_internals.h::CRC_CCITT_START" ref="9239925d5defef5677f3a6f5a5425665" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_CCITT_START&nbsp;&nbsp;&nbsp;0xFFFF          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initial CRC value for CCITT-CRC calculation. 
</div>
</div><p>
<a class="anchor" name="4193f399cfecf510bd0f451145d5c73e"></a><!-- doxytag: member="mxc_scc_internals.h::CRC_POLYNOMIAL" ref="4193f399cfecf510bd0f451145d5c73e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_POLYNOMIAL&nbsp;&nbsp;&nbsp;0x1021          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The polynomial used in CCITT-CRC calculation 
</div>
</div><p>
<a class="anchor" name="b3606671834386bd0e1e0eac03550c8d"></a><!-- doxytag: member="mxc_scc_internals.h::CRC_SIZE_BYTES" ref="b3606671834386bd0e1e0eac03550c8d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC_SIZE_BYTES&nbsp;&nbsp;&nbsp;(sizeof(<a class="el" href="mxc__scc__internals_8h.html#6b6c21dae2994d1cc6afc120b32719bf">crc_t</a>))          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shorthand (clearer, anyway) for number of bytes in a CRC. 
</div>
</div><p>
<a class="anchor" name="6ed9fa6b98f7086b7aa0dd9037235451"></a><!-- doxytag: member="mxc_scc_internals.h::PADDING_BUFFER_MAX_BYTES" ref="6ed9fa6b98f7086b7aa0dd9037235451" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PADDING_BUFFER_MAX_BYTES&nbsp;&nbsp;&nbsp;(CRC_SIZE_BYTES + sizeof(scc_block_padding))          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum number of additional bytes which may be added in CRC+padding mode. 
</div>
</div><p>
<a class="anchor" name="4ef50d172fae68a2d27b8756992abcd7"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_BLOCK_SIZE_BYTES" ref="4ef50d172fae68a2d27b8756992abcd7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_BLOCK_SIZE_BYTES          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;scc_configuration.block_size_bytes</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine number of bytes in an SCC block<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Bytes / block </dd></dl>

</div>
</div><p>
<a class="anchor" name="0caef88f3a6619900f2bada5c0bc7d3c"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_BYTE_OFFSET" ref="0caef88f3a6619900f2bada5c0bc7d3c" args="(bp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_BYTE_OFFSET          </td>
          <td>(</td>
          <td class="paramtype">bp&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((uint32_t)(bp) % sizeof(uint32_t))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the byte offset into a word <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bp</em>&nbsp;</td><td>The byte (char*) pointer </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The offset (0, 1, 2, or 3) </dd></dl>

</div>
</div><p>
<a class="anchor" name="4adc1dda358a585080339b4de99d8c23"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_CALLBACK_SIZE" ref="4adc1dda358a585080339b4de99d8c23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_CALLBACK_SIZE&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of function pointers which can be stored in scc_callbacks. Defaults to 4, can be overridden with compile-line argument. 
</div>
</div><p>
<a class="anchor" name="d5f769fdb0725ddeadfa2e59f389d465"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_CIPHER_MAX_POLL_COUNT" ref="d5f769fdb0725ddeadfa2e59f389d465" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_CIPHER_MAX_POLL_COUNT&nbsp;&nbsp;&nbsp;100          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of times to polling SCC while waiting for cipher or zeroizing function to complete. See also <a class="el" href="mxc__scc__internals_8h.html#bb82ed96aa7d1d30d2131df742311f2b">SCC_SPIN_COUNT</a>. 
</div>
</div><p>
<a class="anchor" name="175a20b5baf522f0a7857caf49eee52a"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_DRIVER_NAME" ref="175a20b5baf522f0a7857caf49eee52a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_DRIVER_NAME&nbsp;&nbsp;&nbsp;&quot;scc&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Name of the driver. Used (on Linux, anyway) when registering interrupts 
</div>
</div><p>
<a class="anchor" name="485db94f63d5efeac41b2206fe0f36f7"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_DRIVER_PAD_CHAR" ref="485db94f63d5efeac41b2206fe0f36f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_DRIVER_PAD_CHAR&nbsp;&nbsp;&nbsp;0x80          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Value of 'beginning of padding' marker in driver-provided padding 
</div>
</div><p>
<a class="anchor" name="516991fd0342bd93006444a1fdd6e330"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_KEY_SLOT_SIZE" ref="516991fd0342bd93006444a1fdd6e330" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_KEY_SLOT_SIZE&nbsp;&nbsp;&nbsp;32          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the size, in bytes, of each key slot, and therefore the maximum size of the wrapped key. 
</div>
</div><p>
<a class="anchor" name="68b9a36d69b0be4a6e7a96980212d970"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_KEY_SLOTS" ref="68b9a36d69b0be4a6e7a96980212d970" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_KEY_SLOTS&nbsp;&nbsp;&nbsp;20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Define the number of Stored Keys which the SCC driver will make available. Value shall be from 0 to 20. Default is zero (0). 
</div>
</div><p>
<a class="anchor" name="af53316da83ffdf7f3baf906cecdd9e3"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_MAX_KEY_SIZE" ref="af53316da83ffdf7f3baf906cecdd9e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_MAX_KEY_SIZE&nbsp;&nbsp;&nbsp;32          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum length of key/secret value which can be stored in SCC. 
</div>
</div><p>
<a class="anchor" name="2004ecefff61cba47a9203986565cd54"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_READ_REGISTER" ref="2004ecefff61cba47a9203986565cd54" args="(offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_READ_REGISTER          </td>
          <td>(</td>
          <td class="paramtype">offset&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;__raw_readl(scc_base+(offset))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a 32-bit value from an SCC register. Macro which depends upon scc_base. Linux readl()/writel() macros operate on 32-bit quantities, as do SCC register reads/writes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>Register offset within SCC.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value from the SCC's register. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bb82ed96aa7d1d30d2131df742311f2b"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_SPIN_COUNT" ref="bb82ed96aa7d1d30d2131df742311f2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_SPIN_COUNT&nbsp;&nbsp;&nbsp;1000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of times to spin between polling of SCC while waiting for cipher or zeroizing function to complete. See also <a class="el" href="mxc__scc__internals_8h.html#d5f769fdb0725ddeadfa2e59f389d465">SCC_CIPHER_MAX_POLL_COUNT</a>. 
</div>
</div><p>
<a class="anchor" name="e7a4d911046e9d482468f6c01a0f7bda"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_WORD_PTR" ref="e7a4d911046e9d482468f6c01a0f7bda" args="(bp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_WORD_PTR          </td>
          <td>(</td>
          <td class="paramtype">bp&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((uint32_t)(bp)) &amp; ~(sizeof(uint32_t)-1))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts (by rounding down) a byte pointer into a word pointer <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bp</em>&nbsp;</td><td>The byte (char*) pointer </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The word (uint32_t) as though it were an aligned (uint32_t*) </dd></dl>

</div>
</div><p>
<a class="anchor" name="56cacc2575f96cb30450915a998767f4"></a><!-- doxytag: member="mxc_scc_internals.h::SCC_WRITE_REGISTER" ref="56cacc2575f96cb30450915a998767f4" args="(offset, value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCC_WRITE_REGISTER          </td>
          <td>(</td>
          <td class="paramtype">offset,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(void)__raw_writel(value, scc_base+(offset))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a 32-bit value to an SCC register. Macro depends upon scc_base. Linux readl()/writel() macros operate on 32-bit quantities, as do SCC register reads/writes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>Register offset within SCC. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>32-bit value to store into the register</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>(void) </dd></dl>

</div>
</div><p>
<a class="anchor" name="769bd388d3a51664ecf61e03c5f66245"></a><!-- doxytag: member="mxc_scc_internals.h::SCM_NON_RESERVED_OFFSET" ref="769bd388d3a51664ecf61e03c5f66245" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCM_NON_RESERVED_OFFSET&nbsp;&nbsp;&nbsp;(SCC_KEY_SLOTS * SCC_KEY_SLOT_SIZE)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the offset into each RAM of the base of the area which is not used for Stored Keys. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="6b6c21dae2994d1cc6afc120b32719bf"></a><!-- doxytag: member="mxc_scc_internals.h::crc_t" ref="6b6c21dae2994d1cc6afc120b32719bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="mxc__scc__internals_8h.html#6b6c21dae2994d1cc6afc120b32719bf">crc_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provide a typedef for the CRC which can be used in encrypt/decrypt 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="2a1b1220356b1bf049d8c5587cef776f"></a><!-- doxytag: member="mxc_scc_internals.h::scc_status" ref="2a1b1220356b1bf049d8c5587cef776f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="mxc__scc__internals_8h.html#2a1b1220356b1bf049d8c5587cef776f">scc_status</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gives high-level view of state of the SCC <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="2a1b1220356b1bf049d8c5587cef776f140dc2ab080d9d62508926c0dc3573e5"></a><!-- doxytag: member="SCC_STATUS_INITIAL" ref="2a1b1220356b1bf049d8c5587cef776f140dc2ab080d9d62508926c0dc3573e5" args="" -->SCC_STATUS_INITIAL</em>&nbsp;</td><td>
State of driver before ever checking </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2a1b1220356b1bf049d8c5587cef776f2c7c111702c276bd0f8d271a58014643"></a><!-- doxytag: member="SCC_STATUS_CHECKING" ref="2a1b1220356b1bf049d8c5587cef776f2c7c111702c276bd0f8d271a58014643" args="" -->SCC_STATUS_CHECKING</em>&nbsp;</td><td>
Transient state while driver loading </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2a1b1220356b1bf049d8c5587cef776f29ffa5534409ef79233f60a44c1e412f"></a><!-- doxytag: member="SCC_STATUS_UNIMPLEMENTED" ref="2a1b1220356b1bf049d8c5587cef776f29ffa5534409ef79233f60a44c1e412f" args="" -->SCC_STATUS_UNIMPLEMENTED</em>&nbsp;</td><td>
SCC is non-existent or unuseable </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2a1b1220356b1bf049d8c5587cef776f2b4e6c8c159c4cdb563c148b62c8fd11"></a><!-- doxytag: member="SCC_STATUS_OK" ref="2a1b1220356b1bf049d8c5587cef776f2b4e6c8c159c4cdb563c148b62c8fd11" args="" -->SCC_STATUS_OK</em>&nbsp;</td><td>
SCC is in Secure or Default state </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2a1b1220356b1bf049d8c5587cef776f8247e670a6b244d46e43d0d18898a206"></a><!-- doxytag: member="SCC_STATUS_FAILED" ref="2a1b1220356b1bf049d8c5587cef776f8247e670a6b244d46e43d0d18898a206" args="" -->SCC_STATUS_FAILED</em>&nbsp;</td><td>
In Failed state </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="f6ec9a9517f46c379193450b84b64b9e"></a><!-- doxytag: member="mxc_scc_internals.h::scc_decrypt" ref="f6ec9a9517f46c379193450b84b64b9e" args="(uint32_t count_in_bytes, const uint8_t *data_in, uint32_t scm_control, uint8_t *data_out, int verify_crc, unsigned long *count_out_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static scc_return_t scc_decrypt           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>count_in_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>scm_control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>verify_crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>count_out_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform a decryption on the input. If <code>verify_crc</code> is true, the last block (maybe the two last blocks) is special - it should contain a CRC and padding. These must be stripped and verified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count_in_bytes</em>&nbsp;</td><td>Count of bytes of ciphertext </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data_in</em>&nbsp;</td><td>Pointer to the ciphertext </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scm_control</em>&nbsp;</td><td>Bit values for the SCM_CONTROL register </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>data_out</em>&nbsp;</td><td>Pointer for storing plaintext </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>verify_crc</em>&nbsp;</td><td>Flag for running CRC - 0 no, else yes </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>count_out_bytes</em>&nbsp;</td><td>Number of bytes available at <code>data_out</code> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1d1ae8faa69e54962a73210f49d83995"></a><!-- doxytag: member="mxc_scc_internals.h::scc_encrypt" ref="1d1ae8faa69e54962a73210f49d83995" args="(uint32_t count_in_bytes, const uint8_t *data_in, uint32_t scm_control, uint8_t *data_out, int add_crc, unsigned long *count_out_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static scc_return_t scc_encrypt           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>count_in_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>scm_control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>add_crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>count_out_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform an encryption on the input. If <code>verify_crc</code> is true, a CRC must be calculated on the plaintext, and appended, with padding, before computing the ciphertext.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count_in_bytes</em>&nbsp;</td><td>Count of bytes of plaintext </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data_in</em>&nbsp;</td><td>Pointer to the plaintext </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scm_control</em>&nbsp;</td><td>Bit values for the SCM_CONTROL register </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>data_out</em>&nbsp;</td><td>Pointer for storing ciphertext </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>add_crc</em>&nbsp;</td><td>Flag for computing CRC - 0 no, else yes </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>count_out_bytes</em>&nbsp;</td><td>Number of bytes available at <code>data_out</code> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="af554f719ba7b95a603f439f040059f7"></a><!-- doxytag: member="mxc_scc_internals.h::scc_perform_callbacks" ref="af554f719ba7b95a603f439f040059f7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void scc_perform_callbacks           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform callbacks registered by scc_monitor_security_failure().<p>
Make sure callbacks only happen once... Since there may be some reason why the interrupt isn't generated, this routine could be called from base(task) level.<p>
One at a time, go through scc_callbacks[] and call any non-null pointers. 
</div>
</div><p>
</div>
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<Title>footer</Title>
</HEAD>
<BODY>
</ul>
</ul>
</ul>
</ul>
<hr size="1">
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1">
  <tr>
    <td width="50%"><small>©&nbsp; Freescale Semiconductor, Inc., 2007.&nbsp; 
    All rights reserved.<br>
    </small><FONT COLOR="#FF0000"><small>Freescale Confidential Proprietary<br>
    </small></FONT><small><FONT COLOR="#FF0000">NDA Required</FONT></small></td>
    <td width="50%"><small>
<a href="http://www.doxygen.org/index.html">
<img src="Freescale25.png" alt="doxygen" align="right" border="0" width="129" height="48"></a></small></td>
  </tr>
</table>
<address style="align: right;">&nbsp;</address>
</body>
</html>
